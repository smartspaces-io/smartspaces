/*
 * Copyright (C) 2016 Keith M. Hughes
 * Copyright (C) 2012 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package io.smartspaces.workbench.project

import _root_.java.io.File
import _root_.java.util.ArrayList
import _root_.java.util.Collection
import _root_.java.util.Collections
import _root_.java.util.HashMap
import _root_.java.util.HashSet
import _root_.java.util.List
import _root_.java.util.Map
import _root_.java.util.Set

import io.smartspaces.configuration.Configuration
import io.smartspaces.logging.ExtendedLog
import io.smartspaces.util.io.CanonicalFileCollector
import io.smartspaces.util.io.FileCollector
import io.smartspaces.util.io.FileSupport
import io.smartspaces.util.io.FileSupportImpl
import io.smartspaces.workbench.project.builder.ProjectBuilder
import io.smartspaces.workbench.project.constituent.ContentProjectConstituent
import io.smartspaces.workbench.project.constituent.ProjectConstituent
import io.smartspaces.workbench.tasks.DependencyWorkbenchTask
import io.smartspaces.workbench.tasks.WorkbenchTaskContext
import io.smartspaces.workbench.tasks.WorkbenchTaskModifiers

import _root_.scala.collection.JavaConverters._

object ProjectTaskContext {

  /**
   * Where things are being built.
   */
  val BUILD_DIRECTORY = "build"

  /**
   * Subdirectory of build folder which contains the staged components of the
   * build.
   */
  val BUILD_STAGING_DIRECTORY = "staging"

  /**
   * Extension for creating temp build directories.
   */
  val TEMP_DIRECTORY_EXTENSION = ".dir"

  /**
   * Sub-directory in which to put temp build files.
   */
  val BUILD_TEMP_DIRECTORY = "tmp"
}

/**
 * A context for building and packaging activities.
 *
 * @author Keith M. Hughes
 */
class ProjectTaskContext(projectType: ProjectType, project: Project,
    workbenchTaskContext: WorkbenchTaskContext) extends ProjectContext {

  /**
   * The file support to use.
   */
  private val fileSupport = FileSupportImpl.INSTANCE

  /**
   * Files to include in the project.
   */
  private val artifactsToInclude: List[File] = new ArrayList()

  /**
   * Files generated by the project.
   */
  private val generatedArtifacts: List[File] = new ArrayList()

  /**
   * The source directories for the project.
   */
  private val sourceDirectories: List[File] = new ArrayList()

  /**
   * The directory where the project will be built.
   */
  private val buildDirectory = fileSupport.newFile(project.getBaseDirectory(), ProjectTaskContext.BUILD_DIRECTORY)

  /**
   * The staging directory for artifacts.
   */
  private val stagingDirectory = fileSupport.newFile(buildDirectory, ProjectTaskContext.BUILD_STAGING_DIRECTORY)

  /**
   * The collection of tasks for the project indexed by task name.
   *
   * TODO(keith): Should this be a multimap?
   */
  private val tasksForProject: Map[String, DependencyWorkbenchTask] = new HashMap()

  /**
   * Project task contexts for projects which this project is dependent on.
   */
  private val dynamicProjectDependencyContexts: Set[ProjectTaskContext] = new HashSet()

  /**
   * The name of the current task being run, can be {@code null}.
   */
  private var currentTaskName: String = _

  /**
   * Collection of dest to src file mappings, constructed during the build
   * process.
   */
  private val sourceMap = new CanonicalFileCollector()

  prepareProjectConfiguration()

  override def getProject(): Project = {
    return project
  }

  override def getWorkbenchTaskContext(): WorkbenchTaskContext = {
    return workbenchTaskContext
  }

  override def getProjectType(): ProjectType = {
    return projectType
  }

  /**
   * Add anything needed to the project configuration.
   */
  private def prepareProjectConfiguration(): Unit = {
    val configuration = project.getConfiguration()
    configuration.setProperty(ProjectBuilder.CONFIGURATION_NAME_PROJECT_HOME,
      project.getBaseDirectory().getAbsolutePath())
    configuration.setProperty(ProjectBuilder.CONFIGURATION_NAME_PROJECT_GENERATED_RESOURCE,
      fileSupport.newFile(buildDirectory, ProjectFileLayout.GENERATED_SOURCE_ROOT)
        .getAbsolutePath())
  }

  override def getProjectTargetFile(rootDirectory: File, target: String): File = {
    val targetPath = project.getConfiguration().evaluate(target)

    return fileSupport.resolveFile(rootDirectory, targetPath)
  }

  override def getResourceFileCollector(): FileCollector = {
    return sourceMap
  }

  /**
   * Get the root build directory.
   *
   * @return the root of the build directory
   */
  def getRootBuildDirectory(): File = {
    return buildDirectory
  }

  /**
   * Get a sub directory from the build directory.
   *
   * @param subpath
   *          relative path for the sub directory
   *
   * @return the subdirectory
   */
  def getBuildDirectory(subpath: String): File = {
    val subBuild = fileSupport.newFile(getRootBuildDirectory(), subpath)
    fileSupport.directoryExists(subBuild)
    return subBuild
  }

  /**
   * Get the root staging directory.
   *
   * @return the root of the staging directory
   */
  def getStagingDirectory(): File = {
    return stagingDirectory
  }

  /**
   * Get a unique temporary build directory.
   *
   * @return a temporary build directory
   */
  def getTempBuildDirectory(): File = {
    val tempDirectory = fileSupport.newFile(buildDirectory, ProjectTaskContext.BUILD_TEMP_DIRECTORY)
    fileSupport.mkdir(tempDirectory)
    val tempFile = fileSupport.createTempFile(tempDirectory)
    return fileSupport.newFile(tempDirectory, tempFile.getName() + ProjectTaskContext.TEMP_DIRECTORY_EXTENSION)
  }

  /**
   * Add a new artifact to go in the file.
   *
   * @param artifact
   *          artifact to add to context
   */
  def addArtifactToInclude(artifact: File): Unit = {
    artifactsToInclude.add(artifact)
  }

  /**
   * Get the list of artifacts to add to the project.
   *
   * @return the list of artifacts to add to the project
   */
  def getArtifactsToInclude(): List[File] = {
    return artifactsToInclude
  }

  /**
   * Add a new generated artifact.
   *
   * @param artifact
   *          the generated artifact
   */
  def addGeneratedArtifact(artifact: File): Unit = {
    generatedArtifacts.add(artifact)
  }

  /**
   * Get the list of artifacts generated.
   *
   * <p>
   * Only valid after a build.
   *
   * @return the list of generated artifacts
   */
  def getGeneratedArtifacts(): List[File] = {
    return generatedArtifacts
  }

  /**
   * Add in a source directory for this project.
   *
   * @param sourceDirectory
   *          the directory to add
   *
   * @return this context
   */
  def addSourceDirectory(sourceDirectory: File): ProjectTaskContext = {
    sourceDirectories.add(sourceDirectory)

    return this
  }

  /**
   * Get the source directories for the project.
   *
   * @return the source directories
   */
  def getSourceDirectories(): List[File] = {
    return sourceDirectories
  }

  /**
   * Add in a task that has been created for this project.
   *
   * <p>
   * The task will also be added to the workbench task context.
   *
   * @param task
   *          the task to add
   *
   * @return this context
   */
  def addProjectTask(task: DependencyWorkbenchTask): ProjectTaskContext = {
    if (tasksForProject.put(task.getName(), task) != null) {
      getLog().warn(s"There was a previous task with name ${task.getName} which has been dropped")
    }

    workbenchTaskContext.addTasks(task)

    return this
  }

  /**
   * Modify the project tasks associated with this context with the provided
   * modifiers.
   *
   * @param modifiersCollection
   *          the modifiers to be applied
   *
   * @return this context
   */
  def modifyProjectTasks(modifiersCollection: Collection[WorkbenchTaskModifiers]): ProjectTaskContext = {
    modifiersCollection.asScala.foreach { modifiers =>
      val task = tasksForProject.get(modifiers.getTaskName())
      if (task != null) {
        task.applyTaskModifiers(modifiers)
      } else {
        getLog().warn(s"Task modifier found for missing task ${modifiers.getTaskName()}")
      }
    }

    return this
  }

  /**
   * Add a task context for a dynamic project dependency.
   *
   * @param dependencyTaskContext
   *          the dependency task context to add
   *
   * @return this context
   */
  def addDynamicProjectDependencyContext(dependencyTaskContext: ProjectTaskContext): ProjectTaskContext = {
    dynamicProjectDependencyContexts.add(dependencyTaskContext)

    return this
  }

  /**
   * Add a task context for a dynamic project dependency.
   *
   * @param dependencyTaskContexts
   *          the dependency task contexts to add
   *
   * @return this context
   */
  def addDynamicProjectDependencyContexts(dependencyTaskContexts: Collection[ProjectTaskContext]): ProjectTaskContext = {
    dynamicProjectDependencyContexts.addAll(dependencyTaskContexts)

    return this
  }

  /**
   * Get the project task contexts for all dynamic project dependencies.
   *
   * @return the dependency project task contexts
   */
  def getDynamicProjectDependencyContexts(): Set[ProjectTaskContext] = {
    return dynamicProjectDependencyContexts
  }

  /**
   * Process the extra constituents for the project.
   */
  def processExtraConstituents(): Unit = {
    val constituents = project.getExtraConstituents()
    if (constituents != null) {
      constituents.asScala.foreach { constituent =>
        constituent.processConstituent(project, this)
      }
    }
  }

  /**
   * Process any generated resources for the project.
   *
   * @param stagingDirectory
   *          the directory where the processed content should go
   */
  def processGeneratedResources(stagingDirectory: File): Unit = {
    val generatedResources =
      fileSupport.newFile(getRootBuildDirectory(), ProjectFileLayout.SOURCE_GENERATED_MAIN_RESOURCES)
    if (fileSupport.isDirectory(generatedResources)) {
      fileSupport.copyDirectory(generatedResources, stagingDirectory, true)
    }
  }

  /**
   * Process the needed resources for the project.
   *
   * @param stagingDirectory
   *          the directory where the processed content should go
   */
  def processResources(stagingDirectory: File): Unit = {
    processContentConstituents(project.getResources(), stagingDirectory)
  }

  /**
   * Process the needed sources for the project.
   *
   * @param stagingDirectory
   *          the directory where the processed content should go
   */
  def processSources(stagingDirectory: File): Unit = {
    processContentConstituents(project.getSources(), stagingDirectory)
  }

  /**
   * Process the list of constituents for the project.
   *
   * @param constituents
   *          constituents to process
   * @param stagingDirectory
   *          the directory where the processed content should go
   */
  private def processContentConstituents(constituents: List[ContentProjectConstituent],
    stagingDirectory: File): Unit = {
    if (constituents == null) {
      return
    }

    constituents.asScala.foreach { constituent =>
      constituent.processConstituent(project, stagingDirectory, this)
    }
  }

  /**
   * Get the current task name for this context.
   *
   * <p>
   * It will be {@code null} when tasks are not running against the context.
   *
   * @return the current task name
   */
  def getCurrentTaskName(): String = {
    return currentTaskName
  }

  /**
   * Set the current task name for this context.
   *
   * <p>
   * It should be {@code null} when tasks are not running against the context.
   *
   * @param currentTaskName
   *          the current task name
   */
  def setCurrentTaskName(currentTaskName: String): Unit = {
    this.currentTaskName = currentTaskName
  }

  override def getLog(): ExtendedLog = {
    return getWorkbenchTaskContext().getLog()
  }
}
